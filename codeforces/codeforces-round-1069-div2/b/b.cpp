#include <bits/stdc++.h>

/**
 * problem B (2/7)
 * codeforces, codeforces-round-1069-div2
 * author: @shamir0xe
 * generated by contest-builder
 * https://github.com/shamir0xe/contest-builder
 **/

typedef long long ll;
typedef std::pair<int, int> pii;
typedef std::vector<int> vi;
typedef std::vector<long long> vl;
typedef std::vector<std::vector<int>> vvi;
typedef std::vector<std::vector<ll>> vvl;
#define range(i, n) for (int i = 0; i < n; ++i)
#define rrange(i, n) for (int i = n - 1; i >= 0; --i)
#define fr(i, a, n) for (int i = a; i < n; ++i)
#define rfr(i, a, n) for (int i = n - 1; i >= a; --i)
#define trace(x) std::cerr << #x << " : " << x << std::endl
#define _ << " " <<
#define sz(x) ((int)(x).size())
#define all(x) (x).begin(), (x).end()
#define X first
#define Y second

/**
 * printing tuples
 **/
template <size_t n, typename... T>
typename std::enable_if<(n >= sizeof...(T))>::type
__tuple_printer(std::ostream &os, const std::tuple<T...> &tup) {};

template <size_t n, typename... T>
typename std::enable_if<(n < sizeof...(T))>::type
__tuple_printer(std::ostream &os, const std::tuple<T...> &tup) {
  if (n != 0) {
    os << " ";
  }
  os << std::get<n>(tup);
  __tuple_printer<n + 1>(os, tup);
};

template <typename... T>
std::ostream &operator<<(std::ostream &os, const std::tuple<T...> &tup) {
  os << "(";
  __tuple_printer<0>(os, tup);
  os << ")";
  return os;
}

/**
 * printing pairs
 **/
template <typename T, typename K>
std::ostream &operator<<(std::ostream &os, const std::pair<T, K> &p) {
  os << "(" << p.first << " " << p.second << ")";
  return os;
}

/**
 * printing vectors
 **/
template <class T>
std::ostream &operator<<(std::ostream &os, const std::vector<T> &v) {
  os << "[";
  bool first = true;
  for (auto ii = v.begin(); ii != v.end(); ++ii) {
    if (first) {
      first = false;
    } else {
      os << " ";
    }
    os << (*ii);
  }
  os << "]";
  return os;
}

template <typename T, typename K = std::function<void(void)>>
void smin(T &a, T b, const K callable = []() {}) {
  if (a > b) {
    a = b;
    callable();
  }
}

template <typename T, typename K = std::function<void(void)>>
void smax(T &a, T b, const K callable = []() {}) {
  if (a < b) {
    a = b;
    callable();
  }
}

/**
 * Reader class
 **/
class Reader {
public:
  template <typename T> inline static T primitive() {
    T temp;
    std::cin >> temp;
    return temp;
  }

  template <typename T> static std::vector<T> vector(int n) {
    std::vector<T> res(n);
    range(i, n) { res[i] = Reader::primitive<T>(); }
    return res;
  }

  template <typename T, size_t n> static std::array<T, n> array() {
    std::array<T, n> res;
    range(i, n) { res[i] = Reader::primitive<T>(); }
    return res;
  }

  static void sync() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
  }
};

namespace atcoder {
namespace internal {

#if __cplusplus >= 202002L

using std::bit_ceil;

#else

// @return same with std::bit::bit_ceil
unsigned int bit_ceil(unsigned int n) {
  unsigned int x = 1;
  while (x < (unsigned int)(n)) {
    x *= 2;
  }
  return x;
}

#endif

// @param n `1 <= n`
// @return same with std::bit::countr_zero
int countr_zero(unsigned int n) {
#ifdef _MSC_VER
  unsigned long index;
  _BitScanForward(&index, n);
  return index;
#else
  return __builtin_ctz(n);
#endif
}

// @param n `1 <= n`
// @return same with std::bit::countr_zero
constexpr int countr_zero_constexpr(unsigned int n) {
  int x = 0;
  while (!(n & (1 << x))) {
    x++;
  }
  return x;
}

} // namespace internal

#if __cplusplus >= 201703L

template <class S, auto op, auto e, class F, auto mapping, auto composition,
          auto id>
struct lazy_segtree {
  static_assert(std::is_convertible_v<decltype(op), std::function<S(S, S)>>,
                "op must work as S(S, S)");
  static_assert(std::is_convertible_v<decltype(e), std::function<S()>>,
                "e must work as S()");
  static_assert(
      std::is_convertible_v<decltype(mapping), std::function<S(F, S)>>,
      "mapping must work as S(F, S)");
  static_assert(
      std::is_convertible_v<decltype(composition), std::function<F(F, F)>>,
      "composition must work as F(F, F)");
  static_assert(std::is_convertible_v<decltype(id), std::function<F()>>,
                "id must work as F()");

#else

template <class S, S (*op)(S, S), S (*e)(), class F, S (*mapping)(F, S),
          F (*composition)(F, F), F (*id)()>
struct lazy_segtree {

#endif

public:
  lazy_segtree() : lazy_segtree(0) {}
  explicit lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}
  explicit lazy_segtree(const std::vector<S> &v) : _n(int(v.size())) {
    size = (int)internal::bit_ceil((unsigned int)(_n));
    log = internal::countr_zero((unsigned int)size);
    d = std::vector<S>(2 * size, e());
    lz = std::vector<F>(size, id());
    for (int i = 0; i < _n; i++) {
      d[size + i] = v[i];
    }
    for (int i = size - 1; i >= 1; i--) {
      update(i);
    }
  }

  void set(int p, S x) {
    assert(0 <= p && p < _n);
    p += size;
    for (int i = log; i >= 1; i--) {
      push(p >> i);
    }
    d[p] = x;
    for (int i = 1; i <= log; i++) {
      update(p >> i);
    }
  }

  S get(int p) {
    assert(0 <= p && p < _n);
    p += size;
    for (int i = log; i >= 1; i--) {
      push(p >> i);
    }
    return d[p];
  }

  S prod(int l, int r) {
    assert(0 <= l && l <= r && r <= _n);
    if (l == r) {
      return e();
    }

    l += size;
    r += size;

    for (int i = log; i >= 1; i--) {
      if (((l >> i) << i) != l) {
        push(l >> i);
      }
      if (((r >> i) << i) != r) {
        push((r - 1) >> i);
      }
    }

    S sml = e(), smr = e();
    while (l < r) {
      if (l & 1) {
        sml = op(sml, d[l++]);
      }
      if (r & 1) {
        smr = op(d[--r], smr);
      }
      l >>= 1;
      r >>= 1;
    }

    return op(sml, smr);
  }

  S all_prod() { return d[1]; }

  void apply(int p, F f) {
    assert(0 <= p && p < _n);
    p += size;
    for (int i = log; i >= 1; i--) {
      push(p >> i);
    }
    d[p] = mapping(f, d[p]);
    for (int i = 1; i <= log; i++) {
      update(p >> i);
    }
  }
  void apply(int l, int r, F f) {
    assert(0 <= l && l <= r && r <= _n);
    if (l == r) {
      return;
    }

    l += size;
    r += size;

    for (int i = log; i >= 1; i--) {
      if (((l >> i) << i) != l) {
        push(l >> i);
      }
      if (((r >> i) << i) != r) {
        push((r - 1) >> i);
      }
    }

    {
      int l2 = l, r2 = r;
      while (l < r) {
        if (l & 1) {
          all_apply(l++, f);
        }
        if (r & 1) {
          all_apply(--r, f);
        }
        l >>= 1;
        r >>= 1;
      }
      l = l2;
      r = r2;
    }

    for (int i = 1; i <= log; i++) {
      if (((l >> i) << i) != l) {
        update(l >> i);
      }
      if (((r >> i) << i) != r) {
        update((r - 1) >> i);
      }
    }
  }

  template <bool (*g)(S)> int max_right(int l) {
    return max_right(l, [](S x) { return g(x); });
  }
  template <class G> int max_right(int l, G g) {
    assert(0 <= l && l <= _n);
    assert(g(e()));
    if (l == _n) {
      return _n;
    }
    l += size;
    for (int i = log; i >= 1; i--) {
      push(l >> i);
    }
    S sm = e();
    do {
      while (l % 2 == 0) {
        l >>= 1;
      }
      if (!g(op(sm, d[l]))) {
        while (l < size) {
          push(l);
          l = (2 * l);
          if (g(op(sm, d[l]))) {
            sm = op(sm, d[l]);
            l++;
          }
        }
        return l - size;
      }
      sm = op(sm, d[l]);
      l++;
    } while ((l & -l) != l);
    return _n;
  }

  template <bool (*g)(S)> int min_left(int r) {
    return min_left(r, [](S x) { return g(x); });
  }
  template <class G> int min_left(int r, G g) {
    assert(0 <= r && r <= _n);
    assert(g(e()));
    if (r == 0) {
      return 0;
    }
    r += size;
    for (int i = log; i >= 1; i--) {
      push((r - 1) >> i);
    }
    S sm = e();
    do {
      r--;
      while (r > 1 && (r % 2)) {
        r >>= 1;
      }
      if (!g(op(d[r], sm))) {
        while (r < size) {
          push(r);
          r = (2 * r + 1);
          if (g(op(d[r], sm))) {
            sm = op(d[r], sm);
            r--;
          }
        }
        return r + 1 - size;
      }
      sm = op(d[r], sm);
    } while ((r & -r) != r);
    return 0;
  }

private:
  int _n, size, log;
  std::vector<S> d;
  std::vector<F> lz;

  void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }
  void all_apply(int k, F f) {
    d[k] = mapping(f, d[k]);
    if (k < size) {
      lz[k] = composition(f, lz[k]);
    }
  }
  void push(int k) {
    all_apply(2 * k, lz[k]);
    all_apply(2 * k + 1, lz[k]);
    lz[k] = id();
  }
};

} // namespace atcoder

/**
 * define variables here
 **/
const int maxn = 4 * 1000 * 100 + 5;

/**
 * define functions here
 **/

int xor_(int a, int b) { return a ^ b; }

int max_(int a, int b) {
  if (a < b) {
    return b;
  }
  return a;
}

int mapping(int f, int s) { return xor_(f, s); }

int composition(int f, int g) { return xor_(f, g); }

int e_0() { return 0; }
int id() { return 0; }

auto solve() {
  /**
   * main logic goes here
   **/
  int n;
  int l, r;
  std::cin >> n >> l >> r;
  l--;
  r--;
  atcoder::lazy_segtree<int, xor_, e_0, int, mapping, xor_, id> segment_tree(n +
                                                                             1);
  vi res;
  range(i, n) {
    if (i == r) {
      int value = segment_tree.get(l);
      segment_tree.apply(0, i + 1, value);
      res.push_back(value);
    } else {
      int mx = segment_tree.prod(0, i + 1);
      trace(i _ mx + 1);
      segment_tree.apply(0, i + 1, mx + 1);
      range(j, i + 1) { trace(j _ segment_tree.get(j)); }
      res.push_back(mx + 1);
    }
  }
  range(i, n) { std::cout << res[i] << " \n"[i == n - 1]; }

  range(i, n) { res[i] ^= i - 1 >= 0 ? res[i - 1] : 0; }
  range(i, n) {
    fr(j, i + 1, n) {
      if (((i - 1 >= 0 ? res[i - 1] : 0) ^ res[j]) == 0) {
        trace(i + 1 _ j + 1);
      }
    }
  }
  trace("done");

  return 0;
}

int second_main() {
  auto ans = solve();
  // range(i, n) { std::cout << ans[i] << " \n"[i == sz(ans) - 1]; }
  // std::cout << ans << std::endl;
  return 0;
}

int main() {
  Reader::sync();
  bool test_case = true;
  if (test_case) {
    int t;
    std::cin >> t;
    while (t--) {
      second_main();
    }
  } else {
    second_main();
  }
  return 0;
}
