#include <bits/stdc++.h>

/**
 * problem D (4/4)
 * leetcode, weekly-contest-478Â©leetcode
 * author: @shamir0xe
 * generated by contest-builder
 * https://github.com/shamir0xe/contest-builder
 **/

typedef long long ll;
typedef std::pair<int, int> pii;
typedef std::vector<int> vi;
typedef std::vector<long long> vl;
typedef std::vector<std::vector<int>> vvi;
typedef std::vector<std::vector<ll>> vvl;
#define range(i, n) for (int i = 0; i < n; ++i)
#define rrange(i, n) for (int i = n - 1; i >= 0; --i)
#define fr(i, a, n) for (int i = a; i < n; ++i)
#define rfr(i, a, n) for (int i = n - 1; i >= a; --i)
#define trace(x) std::cout << #x << " : " << x << std::endl
#define _ << " " <<
#define sz(x) ((int)(x).size())
#define all(x) (x).begin(), (x).end()
#define X first
#define Y second

/**
 * printing tuples
 **/
template <size_t n, typename... T>
typename std::enable_if<(n >= sizeof...(T))>::type
__tuple_printer(std::ostream &os, const std::tuple<T...> &tup) {};

template <size_t n, typename... T>
typename std::enable_if<(n < sizeof...(T))>::type
__tuple_printer(std::ostream &os, const std::tuple<T...> &tup) {
  if (n != 0) {
    os << " ";
  }
  os << std::get<n>(tup);
  __tuple_printer<n + 1>(os, tup);
};

template <typename... T>
std::ostream &operator<<(std::ostream &os, const std::tuple<T...> &tup) {
  os << "(";
  __tuple_printer<0>(os, tup);
  os << ")";
  return os;
}

/**
 * printing pairs
 **/
template <typename T, typename K>
std::ostream &operator<<(std::ostream &os, const std::pair<T, K> &p) {
  os << "(" << p.first << " " << p.second << ")";
  return os;
}

/**
 * printing vectors
 **/
template <class T>
std::ostream &operator<<(std::ostream &os, const std::vector<T> &v) {
  os << "[";
  bool first = true;
  for (auto ii = v.begin(); ii != v.end(); ++ii) {
    if (first) {
      first = false;
    } else {
      os << " ";
    }
    os << (*ii);
  }
  os << "]";
  return os;
}

template <typename T, typename K = std::function<void(void)>>
void smin(T &a, T b, const K callable = []() {}) {
  if (a > b) {
    a = b;
    callable();
  }
}

template <typename T, typename K = std::function<void(void)>>
void smax(T &a, T b, const K callable = []() {}) {
  if (a < b) {
    a = b;
    callable();
  }
}

/**
 * define variables here
 **/

const int maxn = 1000 * 100 + 5;

struct Node {
  int mid;
  ll value;
  int count = 0;
  bool leaf() const { return left == -1 && right == -1; }
  int left = -1;
  int right = -1;
} nodes[maxn * 33];

std::vector<int> roots;
int node_cnt = 0;

int new_node(int mid, ll value, int count = 0, int left = -1, int right = -1) {
  int idx = node_cnt++;
  nodes[idx].mid = mid;
  nodes[idx].value = value;
  nodes[idx].count = count;
  nodes[idx].left = left;
  nodes[idx].right = right;
  return idx;
}

int _find_kth(Node *u, Node *v, int cnt) {
  // trace("find_kth called with: " _ u->count _ v->count _ cnt);
  if (u->leaf()) {
    return u->mid;
  }
  int left_count = nodes[u->left].count - nodes[v->left].count;
  if (cnt <= left_count) {
    // trace("going left");
    return _find_kth(&nodes[u->left], &nodes[v->left], cnt);
  } else {
    // trace("going right");
    return _find_kth(&nodes[u->right], &nodes[v->right], cnt - left_count);
  }
}

int find_kth(int lx, int rx, int cnt) {
  rx++, lx++;
  // trace(lx _ rx _ cnt);
  return _find_kth(&nodes[roots[rx]], &nodes[roots[lx - 1]], cnt);
}

Node *left_child(Node *u) { return &nodes[u->left]; }
Node *right_child(Node *u) { return &nodes[u->right]; }

std::pair<ll, int> range_sum(int lx, int rx, int idx, bool lower) {
  ll sum = 0;
  int count = 0;
  rx++, lx++;

  // trace("range_sum called with: " _ lx _ rx _ idx _ lower);
  Node *u = &nodes[roots[rx]];
  Node *v = &nodes[roots[lx - 1]];
  while (!u->leaf()) {
    // trace("at node mid: " _ u->mid _
    // " u->value: " _ u->value _ " v->value: " _ v->value);
    if (lower) {
      if (idx <= u->mid) {
        u = left_child(u);
        v = left_child(v);
      } else {
        sum += nodes[u->left].value - nodes[v->left].value;
        count += nodes[u->left].count - nodes[v->left].count;
        u = right_child(u);
        v = right_child(v);
      }
    } else {
      if (idx <= u->mid) {
        // trace("taking left");
        sum += nodes[u->right].value - nodes[v->right].value;
        count += nodes[u->right].count - nodes[v->right].count;
        u = left_child(u);
        v = left_child(v);
        // trace("done left");
      } else {
        // trace("taking right");
        u = right_child(u);
        v = right_child(v);
        // trace("done right");
      }
    }
  }
  if (lower) {
    if (idx >= u->mid) {
      sum += u->value - v->value;
      count += u->count - v->count;
    }
  } else {
    if (idx < u->mid) {
      sum += u->value - v->value;
      count += u->count - v->count;
    }
  }
  return {sum, count};
}

int build_tree(int l, int r) {
  if (l == r) {
    return new_node(l, 0, 0);
  }
  int mid = (l + r) >> 1;
  int left = build_tree(l, mid);
  int right = build_tree(mid + 1, r);
  return new_node(mid, nodes[left].value + nodes[right].value,
                  nodes[left].count + nodes[right].count, left, right);
}

int insert_node(Node *prev, int l, int r, int idx, int val) {
  if (l == r) {
    return new_node(l, prev->value + val, prev->count + 1);
  }
  int mid = (l + r) >> 1;
  int left = prev->left;
  int right = prev->right;
  if (idx <= mid) {
    left = insert_node(&nodes[prev->left], l, mid, idx, val);
  } else {
    right = insert_node(&nodes[prev->right], mid + 1, r, idx, val);
  }
  return new_node(mid, nodes[left].value + nodes[right].value,
                  nodes[left].count + nodes[right].count, left, right);
};

/**
 * define functions here
 **/

class Solution {
public:
  std::vector<long long> minOperations(std::vector<int> &nums, int k,
                                       std::vector<std::vector<int>> &queries) {
    node_cnt = 0;

    // make values unique
    vi values;
    values.assign(all(nums));
    sort(all(values));
    values.erase(std::unique(all(values)), values.end());

    // build reverse index for values
    std::map<int, int> index_values;
    int m = sz(values);
    int n = sz(nums);
    range(i, m) { index_values[values[i]] = i; }

    std::vector<ll> res;
    // build Persistent Segment Tree
    // trace("before roots");
    roots = std::vector<int>(n + 1, -1);
    roots[0] = build_tree(0, m - 1);
    for (int i = 1; i <= n; i++) {
      int idx = index_values[nums[i - 1]];
      roots[i] = insert_node(&nodes[roots[i - 1]], 0, m - 1, idx, nums[i - 1]);
    }
    // trace("after roots");

    // TODO: RMQ for remainders
    std::vector<std::vector<int>> rm_max(n, vi(16, -1));
    std::vector<std::vector<int>> rm_min(n, vi(16, -1));
    for (int i = 0; i < n; i++) {
      rm_max[i][0] = nums[i] % k;
      rm_min[i][0] = nums[i] % k;
    }
    for (int j = 1; (1 << j) <= n; j++) {
      for (int i = 0; i + (1 << j) - 1 < n; i++) {
        rm_max[i][j] =
            std::max(rm_max[i][j - 1], rm_max[i + (1 << (j - 1))][j - 1]);
        rm_min[i][j] =
            std::min(rm_min[i][j - 1], rm_min[i + (1 << (j - 1))][j - 1]);
      }
    }

    auto rmq_query = [&](int l, int length) {
      int j = std::log2(length);
      int maximum = std::max(rm_max[l][j], rm_max[l + length - (1 << j)][j]);
      int minimum = std::min(rm_min[l][j], rm_min[l + length - (1 << j)][j]);
      // trace("rmq_query: " _ l _ length _ maximum _ minimum);
      return maximum == minimum;
    };

    // run over queries
    for (auto &query : queries) {
      int l = query[0];
      int r = query[1];
      // TODO: feasability check
      if (!rmq_query(l, r - l + 1)) {
        // trace("query not feasible: " _ l _ r);
        res.push_back(-1);
        continue;
      }
      // trace("processing query: " _ l _ r);
      int median_idx = find_kth(l, r, (r - l + 1 + 1) >> 1);
      // trace("median_idx: " _ median_idx);

      auto [lower_sum, lower_cnt] = range_sum(l, r, median_idx, true);
      // trace("lower_sum: " _ lower_sum _ " lower_cnt: " _ lower_cnt);

      auto [upper_sum, upper_cnt] = range_sum(l, r, median_idx, false);
      // trace("upper_sum: " _ upper_sum _ " upper_cnt: " _ upper_cnt);

      ll t1 = upper_sum - values[median_idx] * 1ll * upper_cnt;
      ll t2 = lower_sum - values[median_idx] * 1ll * lower_cnt;
      res.push_back((t1 - t2) / k);
      // trace(res);
    }
    return res;
  }
};

auto test_1() {
  std::vector<int> nums{1, 4, 7};
  int k = 3;
  std::vector<std::vector<int>> queries{{0, 1}, {0, 2}};
  std::vector<long long> res = Solution().minOperations(nums, k, queries);
  return res;
}

auto test_2() {
  std::vector<int> nums{1, 2, 4};
  int k = 2;
  std::vector<std::vector<int>> queries{{0, 2}, {0, 0}, {1, 2}};
  std::vector<long long> res = Solution().minOperations(nums, k, queries);
  return res;
}

// std::vector<int> test_2() {
//   std::string s{"wordgoodgoodgoodbestword"};
//   std::vector<std::string> words{"word", "good", "best", "word"};
//   std::vector<int> res = Solution().findSubstring(s, words);
//   return res;
// }
//
// std::vector<int> test_3() {
//   std::string s{"barfoofoobarthefoobarman"};
//   std::vector<std::string> words{"bar", "foo", "the"};
//   std::vector<int> res = Solution().findSubstring(s, words);
//   return res;
// }

int main() {
  // auto res_1 = test_1();
  // std::cout << "test #1: " << res_1 << std::endl;
  //
  auto res_2 = test_2();
  std::cout << "test #2: " << res_2 << std::endl;

  // auto res_3 = test_3();
  // std::cout << "test #3: " << res_3 << std::endl;
  //
  return 0;
}

//{:snippet}
//{:cutoff}
//{:tests}
//{:main}
