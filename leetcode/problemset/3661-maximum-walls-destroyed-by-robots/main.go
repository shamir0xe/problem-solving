package main

import (
	"fmt"
	"slices"
	"sort"
)

/**
 * problem 3661-maximum-walls-destroyed-by-robots (1/1)
 * leetcode, problemset
 * author: @shamir0xe
 * generated by contest-builder
 * https://github.com/shamir0xe/contest-builder
 **/

func maxWalls(robots []int, distance []int, walls []int) int {
	n := len(robots)
	m := len(walls)
	// []ind -> sorted robots index based on the robots position
	var ind []int
	for i := range n {
		ind = append(ind, i)
	}
	sort.SliceStable(ind, func(i, j int) bool {
		return robots[ind[i]] < robots[ind[j]]
	})
	// sort all walls
	slices.Sort(walls)
	// normalize robots' distances
	left_direction, right_direction := 0, 1
	norm_distance := func(index, dir int) int {
		space := int(1e9)
		if dir == left_direction {
			// left shoot
			if index-1 >= 0 {
				space = robots[ind[index]] - robots[ind[index-1]] - 1
			}
			space = min(space, distance[ind[index]])
		} else {
			// right shoot
			if index+1 < n {
				space = robots[ind[index+1]] - robots[ind[index]] - 1
			}
			space = min(space, distance[ind[index]])
		}
		return space
	}

	// []left_walls -> number of walls that been hit by firing to the left
	left_walls := make([]int, n)
	// []right_walls -> number of walls that been hit by firing to the right
	right_walls := make([]int, n)
	// []between -> number of walls between robots[i] and robots[i + 1]
	between := make([]int, n)
	idx := 0 // iterator for walls
	j := 0   // iterator for robots
	for idx < m && j < n {
		// skip
		for idx < m && walls[idx] < robots[ind[j]]-norm_distance(j, left_direction) {
			idx++
		}
		for idx < m && walls[idx] < robots[ind[j]] {
			left_walls[ind[j]]++
			idx++
		}
		for idx < m && walls[idx] == robots[ind[j]] {
			left_walls[ind[j]]++
			right_walls[ind[j]]++
			idx++
		}
		for idx < m && walls[idx] <= robots[ind[j]]+norm_distance(j, right_direction) {
			right_walls[ind[j]]++
			if j+1 < n && walls[idx] >= robots[ind[j+1]]-norm_distance(j+1, left_direction) {
				left_walls[ind[j+1]]++
			}
			idx++
		}
		j++
	}
	idx = 0
	j = 0
	for idx < m && j < n {
		// skip
		for idx < m && walls[idx] < robots[ind[j]] {
			idx++
		}
		temp := int(1e9)
		if j+1 < n {
			temp = robots[ind[j+1]]
		}
		for idx < m && walls[idx] < temp {
			idx++
			between[ind[j]]++
		}
		if idx < m && walls[idx] == temp {
			between[ind[j]]++
		}
		j++
	}

	// for i := range n {
	// 	fmt.Printf("[%d] (%d, %d)\n", i+1, robots[ind[i]], distance[ind[i]])
	// 	fmt.Printf("[%d] (%d, %d)\n", i+1, left_walls[ind[i]], right_walls[ind[i]])
	// 	if i+1 < n {
	// 		fmt.Printf("between[%d]->[%d]: %d\n", i+1, i+2, between[ind[i]])
	// 	}
	// }

	// [][]dp -> fill it with dp logic
	dp := make([][]int, 2)
	dp[0] = make([]int, 2)
	dp[1] = make([]int, 2)
	cur := 0
	for i := range n {
		// right shoot ->
		dp[cur][right_direction] = right_walls[ind[i]]
		if i-1 >= 0 {
			dp[cur][right_direction] += max(dp[1-cur][0], dp[1-cur][1])
		}
		// left shoot <-
		dp[cur][left_direction] = left_walls[ind[i]]
		if i-1 >= 0 {
			// i - 1 -> left
			dp[cur][left_direction] = max(dp[cur][left_direction], left_walls[ind[i]]+dp[1-cur][left_direction])

			// i - 1 -> right
			if norm_distance(i-1, right_direction)+norm_distance(i, left_direction) >= robots[ind[i]]-robots[ind[i-1]] {
				// have overlap
				dp[cur][left_direction] = max(dp[cur][left_direction], dp[1 - cur][right_direction]-right_walls[ind[i-1]]+between[ind[i-1]])
			} else {
				dp[cur][left_direction] = max(dp[cur][left_direction], left_walls[ind[i]]+dp[1 - cur][right_direction])
			}
		}
		cur = 1 - cur
	}

	return max(dp[1 - cur][0], dp[1 - cur][1])
}

func main() {
	var ans int

	ans = maxWalls([]int{17, 59, 32, 11, 72, 18}, []int{5, 7, 6, 5, 2, 10}, []int{17, 25, 33, 29, 54, 53, 18, 35, 39, 37, 20, 14, 34, 13, 16, 58, 22, 51, 56, 27, 10, 15, 12, 23, 45, 43, 21, 2, 42, 7, 32, 40, 8, 9, 1, 5, 55, 30, 38, 4, 3, 31, 36, 41, 57, 28, 11, 49, 26, 19, 50, 52, 6, 47, 46, 44, 24, 48})
	fmt.Printf("ans: %d\n", ans)

	// ans = maxWalls([]int{4}, []int{3}, []int{1, 10})
	// fmt.Printf("ans: %d\n", ans)
	//
	// ans = maxWalls([]int{10, 2}, []int{5, 1}, []int{5, 2, 7})
	// fmt.Printf("ans: %d\n", ans)
	//
	// ans = maxWalls([]int{1, 2}, []int{100, 1}, []int{10})
	// fmt.Printf("ans: %d\n", ans)
}
