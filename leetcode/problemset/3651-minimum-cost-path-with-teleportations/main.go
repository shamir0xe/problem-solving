package main

import "fmt"

/**
 * problem 3651-minimum-cost-path-with-teleportations (1/1)
 * leetcode, problemset
 * author: @shamir0xe
 * generated by contest-builder
 * https://github.com/shamir0xe/contest-builder
 **/

var (
	inf  int = 1e9
	maxn int = 10000 + 10
)

func minCost(grid [][]int, k int) int {
	n := len(grid)
	m := len(grid[0])
	// first solve the classic dp
	dp := make([][][]int, 2)
	bestValue := make([][]int, 2)
	for iter := range 2 {
		dp[iter] = make([][]int, n)
		bestValue[iter] = make([]int, maxn)
		for i := range n {
			dp[iter][i] = make([]int, m)
			for j := range m {
				dp[iter][i][j] = inf
			}
		}
		for i := range maxn {
			bestValue[iter][i] = inf
		}
	}
	dp[0][n-1][m-1] = 0
	inRange := func(x, y int) bool {
		return x >= 0 && x < n && y >= 0 && y < m
	}
	solve := func(cur int) {
		for i := n - 1; i >= 0; i-- {
			for j := m - 1; j >= 0; j-- {
				for _, move := range [][]int{{+1, 0}, {0, +1}} {
					ii := i + move[0]
					jj := j + move[1]
					if inRange(ii, jj) {
						dp[cur][i][j] = min(dp[cur][i][j], dp[cur][ii][jj]+grid[ii][jj])
					}
				}
				dp[cur][i][j] = min(dp[cur][i][j], bestValue[1^cur][grid[i][j]])
			}
		}
		for i := range n {
			for j := range m {
				bestValue[cur][grid[i][j]] = min(bestValue[cur][grid[i][j]], dp[cur][i][j])
			}
		}
		for i := range maxn {
			if i == 0 {
				continue
			}
			bestValue[cur][i] = min(bestValue[cur][i], bestValue[cur][i-1])
		}
	}
	// iterate through it k times, update the alternate board
	cur := 0
	for ; k >= 0; k-- {
		solve(cur)
		cur ^= 1
	}
	// the ans is dp[0][0]
	return dp[1^cur][0][0]
}

func main() {
	ans := minCost([][]int{{1, 3, 3}, {2, 5, 4}, {4, 3, 5}}, 2)
	fmt.Printf("ans: %d\n", ans)
	fmt.Println("Hello darkness my old fiend :)")
}
