package main

import (
	"container/list"
	"fmt"
	"math/bits"
)

/**
 * problem 3283-maximum-number-of-moves-to-kill-all-pawns (1/1)
 * leetcode, problemset
 * author: @shamir0xe
 * generated by contest-builder
 * https://github.com/shamir0xe/contest-builder
 **/

const n = 50
const inf = 100 * 16

// utilities
func sliceEqual(a, b []int) bool {
	return a[0] == b[0] && a[1] == b[1]
}
func abs(a int) int {
	if a < 0 {
		return -a
	}
	return a
}
func inRange(x, y int) bool {
	return x >= 0 && x < n && y >= 0 && y < n
}

func maxMoves(kx int, ky int, positions [][]int) int {
	var m int = len(positions)
	// make dis[m+1][m+1]: shortest path between nodes
	var dis [][]int = make([][]int, m+1)
	for i := range m + 1 {
		dis[i] = make([]int, m+1)
		for j := range m + 1 {
			dis[i][j] = -1
		}
	}

	// append the night position as the last element
	positions = append(positions, []int{kx, ky})

	var cellCurCollor [][]int8 = make([][]int8, n)
	for i := range n {
		cellCurCollor[i] = make([]int8, n)
	}

	type Elem struct {
		Position []int
		Distance int
	}

	var knightMoves [][]int
	for _, i := range []int{+1, -1, +2, -2} {
		for _, j := range []int{+1, -1, +2, -2} {
			if abs(i*j) != 2 {
				continue
			}
			knightMoves = append(knightMoves, []int{i, j})
		}
	}

	var curColor int8 = 0
	for u := range m + 1 {
		// do BFS m+1 times
		curColor++
		var count int = 0
		dis[u][u] = 0
		qu := list.New()
		qu.PushBack(Elem{positions[u], 0})
		for count < m && qu.Len() > 0 {
			front := qu.Front().Value.(Elem)
			qu.Remove(qu.Front())
			// update distances
			for v := range m + 1 {
				if sliceEqual(positions[v], front.Position) && dis[u][v] == -1 {
					dis[u][v] = front.Distance
					count++
				}
			}
			// update the knight moves
			for _, move := range knightMoves {
				x := move[0] + front.Position[0]
				y := move[1] + front.Position[1]
				if inRange(x, y) && cellCurCollor[x][y] != curColor {
					cellCurCollor[x][y] = curColor
					qu.PushBack(Elem{[]int{x, y}, front.Distance + 1})
				}
			}
		}
	}

	// calculate dp
	checkItsAliceTurn := func(mask int) bool {
		return bits.OnesCount(uint(mask))%2 == m%2
	}
	var dp [][]int = make([][]int, 1<<m)
	dp[0] = make([]int, m)
	for i := range m {
		dp[0][i] = 0
	}
	for mask := 1; mask < (1 << m); mask++ {
		// find if it's the Alice turn
		aliceTurn := checkItsAliceTurn(mask)
		// initialize the row
		dp[mask] = make([]int, m)
		for i := range m {
			if aliceTurn {
				dp[mask][i] = 0
			} else {
				dp[mask][i] = inf
			}
		}
		for i := range m {
			for j := range m {
				// chek if the j'th bit is on
				if (mask>>j)&1 == 1 {
					var alterMask int = mask ^ (1 << j)
					if aliceTurn {
						dp[mask][i] = max(dp[mask][i], dp[alterMask][j]+dis[i][j])
					} else {
						// Bob's turn
						dp[mask][i] = min(dp[mask][i], dp[alterMask][j]+dis[i][j])
					}
				}
			}
		}
	}
	var ans int = 0
	for i := range m {
		ans = max(ans, dis[m][i]+dp[((1<<m)-1)^(1<<i)][i])
	}
	return ans
}

func main() {
	ans := maxMoves(0, 2, [][]int{{1, 1}, {2, 2}, {3, 3}})
	fmt.Println(ans)
}
