from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
import sys
from typing import Dict, List, Tuple
import re

## problem bazaar-interview (1/1)
## local, problemset
## author: @shamir0xe
## generated by contest-builder
## https://github.com/shamir0xe/contest-builder

"""
Notes

I've made some considerations before implementing the required code, some of them are as follows:

    1) There were no explicit conditions that the CourseIDs and StudentIDs are distinct. So I've created
    a mapping from each one to some unique integer ID made by the IdGenerator class. To achieve it,
    I defined a Singleton class which ensures derived classes from it have at most one instance.

    2) From the statements of the problem, I could not find whether nested requests could exist or not.
    So I've implemented a way to support nested queries, which means you can give it 2 or more nested queries
    and it works fine and each query will be pushed with some stack properties.

    3) It's a common practice to use validators before passing them to functions/handlers. However, due to this problem,
    we could not have them due to restrictions on the provider site. So I came to the conclusion that I implemented
    some validators by myself. DTO classes (short for Data Transfer Object) that are presented below are for this purpose.

    4) I've separated reads/writes into different classes and used abstraction according to the "Open/Close" principle.

    5) There is no place for tests but for sure it is needed before saying it is logically approvable.

"""

## Enums


class Scopes(Enum):
    ADD = "add"
    GRADE = "grade"
    STATS = "stats"
    EXIT = "exit"
    INIT = "init"


class Types(Enum):
    STUDENT = "student"
    COURSE = "course"


## Singleton & ID Generator


class Singleton(type):
    """Copy pasta singleton class from the web (in order to have a singleton base class)"""

    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]


class IdGenerator(metaclass=Singleton):
    """
    Generates unique id by calling next
    IDs get generated from 0
    """

    def __init__(self) -> None:
        self.current_id = -1

    def next(self) -> int:
        self.current_id += 1
        return self.current_id


## I/O Interfaces


class QueryReader(ABC):
    @abstractmethod
    def read_query(self) -> str:
        pass


class StandardInputQuery(QueryReader):
    def read_query(self) -> str:
        return sys.stdin.readline()


class ResponseWriter(ABC):
    @abstractmethod
    def write(self, data: str) -> None:
        pass


class StandardOutputWriter(ResponseWriter):
    def write(self, data: str) -> None:
        print(data)


## Custom Exceptoins


class InvalidArgumentsError(Exception):
    pass


## DTOs (Validators)


@dataclass
class AddDTO:
    args: List[str]
    add_type: Types = field(default=Types.STUDENT)
    id: str = field(default="")

    def __post_init__(
        self,
    ) -> None:
        try:
            self.add_type = Types(self.args[0].lower())
            self.id = self.args[1]
        except Exception:
            raise InvalidArgumentsError(
                f"invalid args provided for AddDTO: {self.args}"
            )


@dataclass
class ScopeDTO:
    args: List[str]
    scope: Scopes = field(default=Scopes.INIT)

    def __post_init__(
        self,
    ) -> None:
        try:
            self.scope = Scopes(self.args[0].lower())
        except Exception:
            raise InvalidArgumentsError(
                f"invalid args provided for ScopeDTO: {self.args}"
            )


@dataclass
class GradeDTO:
    args: List[str]
    course_id: str = field(default="")
    student_id: str = field(default="")
    grade: float = field(default=0)

    def __post_init__(
        self,
    ) -> None:
        try:
            self.course_id = self.args[0]
            self.student_id = self.args[1]
            self.grade = float(self.args[2])
        except Exception:
            raise InvalidArgumentsError(
                f"invalid args provided for GradeDTO: {self.args}"
            )


@dataclass
class StatsDTO:
    args: List[str]
    stats_type: Types = field(default=Types.STUDENT)
    id: str = field(default="")

    def __post_init__(
        self,
    ) -> None:
        try:
            self.stats_type = Types(self.args[0].lower())
            self.id = self.args[1]
        except Exception:
            raise InvalidArgumentsError(
                f"invalid args provided for StatsDTO: {self.args}"
            )


## Command Parser


class CommandParser:
    @staticmethod
    def parse(query: str) -> List[str]:
        """Tokenize a query string"""
        query = re.sub(r"[ \t\n\r\f\v]+", " ", query)
        query = query.strip()
        return query.split(" ")


@dataclass
class Runner:
    """Main Class"""

    response_writer: ResponseWriter
    is_ended: bool = False
    scopes: List[Scopes] = field(default_factory=lambda: [Scopes.INIT])
    new_ones: List[int] = field(default_factory=list)
    students: Dict[str, int] = field(default_factory=lambda: {})
    courses: Dict[str, int] = field(default_factory=lambda: {})
    inverse_ids: List[str] = field(
        default_factory=list
    )  # both students and courses (imprv: separate them!)
    students_grades: Dict[int, Dict[int, float]] = field(default_factory=lambda: {})

    @property
    def end(self) -> bool:
        return self.is_ended

    @property
    def current_scope(self) -> Scopes:
        return self.scopes[-1]

    def handle_scope(self, scope: Scopes) -> None:
        """Handler for the scope commands: ADD, GRADE, STATS, EXIT"""
        if scope is Scopes.EXIT:
            self.is_ended = True
        else:
            # Append the current scope
            if scope is Scopes.ADD:
                self.new_ones += [0]
            self.scopes += [scope]

    def handle_add(self, current_type: Types, id: str) -> bool:
        """Handler for ADD command"""
        new_one = False
        if current_type is Types.STUDENT:
            if id not in self.students:
                self.students[id] = IdGenerator().next()
                self.inverse_ids += [id]
                new_one = True
        else:
            # current_type is Types.COURSE
            if id not in self.courses:
                self.courses[id] = IdGenerator().next()
                self.inverse_ids += [id]
                new_one = True
        return new_one

    def handle_grade(
        self, course_id_org: str, student_id_org: str, grade: float
    ) -> None:
        """Handler for GRADE command"""
        course_id, student_id = -1, -1
        if course_id_org in self.courses:
            course_id = self.courses[course_id_org]
        if student_id_org in self.students:
            student_id = self.students[student_id_org]
        if course_id == -1 or student_id == -1:
            self.response_writer.write("INVALID DATA")
            return
        if not student_id in self.students_grades:
            self.students_grades[student_id] = {}
        self.students_grades[student_id][course_id] = grade

    def handle_stats(self, stats_type: Types, id_org: str) -> None:
        """Handler for STATS command"""
        output: List[Tuple[float, str]] = []
        summation = 0
        counter = 0
        id = -1

        if stats_type is Types.STUDENT:
            # should output the students info
            if id_org in self.students:
                id = self.students[id_org]
            if id == -1:
                self.response_writer.write("INVALID DATA")
                return
            for course_id, grade in self.students_grades[id].items():
                output += [(grade, self.inverse_ids[course_id])]
                summation += grade
                counter += 1
        else:
            # should output the course's info
            if id_org in self.courses:
                id = self.courses[id_org]
            if id == -1:
                self.response_writer.write("INVALID DATA")
                return

            for student_id, info in self.students_grades.items():
                if id in info:
                    grade = info[id]
                    output += [(grade, self.inverse_ids[student_id])]
                    summation += grade
                    counter += 1

        output = sorted(output, key=lambda x: (-x[0], x[1]))
        for grade, alter_id in output:
            self.response_writer.write(f"{alter_id} {grade:.2f}")
        avg = summation / counter
        self.response_writer.write(f"{avg:.2f}")

    def handle_query(self, query: str) -> None:
        """General query handler, it dispatchs the query to the right handler"""
        args: List[str] = CommandParser.parse(query)
        if args[0] == "END":
            # Pop the current scope from the top of the stack
            if self.current_scope == Scopes.ADD:
                self.response_writer.write(f"{self.new_ones[-1]}")
                self.new_ones.pop()
            self.scopes.pop()
            return
        if self.current_scope is Scopes.ADD:
            data = AddDTO(args)
            if self.handle_add(data.add_type, data.id):
                self.new_ones[-1] += 1
        elif self.current_scope is Scopes.GRADE:
            data = GradeDTO(args)
            self.handle_grade(data.course_id, data.student_id, data.grade)
        elif self.current_scope is Scopes.STATS:
            data = StatsDTO(args)
            self.handle_stats(data.stats_type, data.id)
        else:
            # it should be INIT scope, expecting Scope commands
            data = ScopeDTO(args)
            self.handle_scope(data.scope)


def main():
    response_writer: ResponseWriter = StandardOutputWriter()
    runner = Runner(response_writer=response_writer)
    dependency: QueryReader = StandardInputQuery()
    while not runner.end:
        query = dependency.read_query()
        runner.handle_query(query)


if __name__ == "__main__":
    main()
