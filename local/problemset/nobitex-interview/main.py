from dataclasses import dataclass, field
from typing import Callable, Dict, List
import time
from pydantic import BaseModel
import requests
import logging

## roblem nobitex-interview (1/1)
## local, problemset
## author: @shamir0xe
## generated by contest-builder
## https://github.com/shamir0xe/contest-builder


LOGGER = logging.getLogger(__name__)
LOOP = 55
SLEEP_TIME = 0.05
BASE_URL = "http://750a-169-150-201-18.ngrok-free.app"


class FetchBody(BaseModel):
    index: int
    sentence: str


class FetchResult(BaseModel):
    status_code: int
    body: FetchBody


class PostResult(BaseModel):
    status_code: int
    body: str


@dataclass
class Solver:
    fetch_fn: Callable[[str], FetchResult]
    post_fn: Callable[[str, List[str]], PostResult]
    requests: List[str] = field(default_factory=list)
    hashes: Dict[str, List[int]] = field(default_factory=dict)

    @property
    def _fetch_url(self):
        return f"{BASE_URL}/get-sentence"

    @property
    def _push_url(self):
        return f"{BASE_URL}/push-response"

    def fetch_data(self) -> str:
        r = self.fetch_fn(self._fetch_url)
        # r = requests.get(self._fetch_url)
        if r.status_code != 200:
            self.rate_limitter()
            return self.fetch_data()
        res = r.body.sentence
        # res = r.json()["sentence"].strip()
        LOGGER.info(f"fetched res: -{res}-")
        return res

    def send_result(self, *args) -> None:
        # pack args to send
        LOGGER.info(f"going to send [{args}]")
        r = self.post_fn(self._push_url, args)  # type: ignore
        # r = requests.post(self._push_url, json=args)
        LOGGER.info(f"status code: {r.status_code}")
        # LOGGER.info(r.text)
        if r.status_code not in [200, 400]:
            self.rate_limitter()
            self.send_result(*args)
        if r.status_code == 400:
            LOGGER.info(r.body)

    def rate_limitter(self) -> None:
        LOGGER.info("waiting...")
        time.sleep(SLEEP_TIME)

    def make_hash(self, cur: str) -> str:
        res = ""
        tokens = cur.split()
        res += f"{len(tokens)}"
        for token in tokens:
            res += f"|{len(token)}"
        return res

    def insert_instance(self, cur: str) -> bool:
        hash = self.make_hash(cur)
        id = len(self.requests)
        found = False
        if hash in self.hashes:
            # check for duplication
            for alter_id in self.hashes[hash]:
                if self.requests[alter_id] == cur:
                    return False
            self.hashes[hash] += [id]
            found = True
        else:
            self.hashes[hash] = [id]
        # append to the requests list
        self.requests += [cur]
        return found

    def unpack_family(self, cur: str) -> List[str]:
        hash = self.make_hash(cur)
        return [self.requests[id] for id in self.hashes[hash]]

    def do(self) -> None:
        for _ in range(LOOP):
            cur = self.fetch_data()
            found = self.insert_instance(cur)
            if found:
                data_pack = self.unpack_family(cur)
                self.send_result(*data_pack)
            self.rate_limitter()


def main():
    logging.basicConfig(level="INFO", format="%(levelname)s: %(message)s")
    LOGGER.info("init")
    test = False
    if test:

        def test_input_generator():
            with open("main.in", "r") as f:
                status_code = int(f.readline().strip())
                index = int(f.readline().strip())
                sentence = f.readline()
                yield FetchResult(
                    status_code=status_code,
                    body=FetchBody(index=index, sentence=sentence),
                )

        input_gen = test_input_generator()

        def fetch_fn(url) -> FetchResult:
            return next(input_gen)

        def test_output_generator():
            with open("main.out", "r") as f:
                status_code = int(f.readline().strip())
                length = int(f.readline().strip())
                body = "\n".join([f.readline().strip() for _ in range(length)])
                yield PostResult(status_code=status_code, body=body)

        output_gen = test_output_generator()

        def post_fn(url, args) -> PostResult:
            r = next(output_gen)
            alter_body = "\n".join(args)
            if r.status_code == 200:
                assert alter_body == r.body
            return PostResult(status_code=r.status_code, body=r.body)

    else:

        def fetch_fn(url) -> FetchResult:
            r = requests.get(url)
            index, sentence = -1, ""
            if r.status_code == 200:
                index = r.json()["index"]
                sentence = r.json()["sentence"]
            return FetchResult(
                status_code=r.status_code,
                body=FetchBody(index=index, sentence=sentence),
            )

        def post_fn(url, args) -> PostResult:
            r = requests.post(url, json=args)
            return PostResult(status_code=r.status_code, body=r.text)

    solver = Solver(fetch_fn=fetch_fn, post_fn=post_fn)
    solver.do()


if __name__ == "__main__":
    main()
