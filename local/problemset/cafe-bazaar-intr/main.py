from __future__ import annotations
import sys
from typing import Dict, Tuple

sys.setrecursionlimit(2 * 10**5)
# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

## problem cafe-bazaar-intr (1/1)
## local, problemset
## author: @shamir0xe
## generated by contest-builder
## https://github.com/shamir0xe/contest-builder


# define variables
n: int = 0
some_list: list[str]


# define other functions here
def fn():
    return (n**2,)


class TrieTree:
    adj: Dict[int, Dict[str, int]]
    reverse_idx: Dict[int, int]  # node idx -> input idx

    def __init__(self) -> None:
        # initialize
        self.adj = {}
        self.reverse_idx = {}

        # make the root
        self.new_node()

    def add(self, word: str, word_idx: int) -> int:
        node = 0
        flag: bool = False
        for char in word:
            if not char in self.adj[node]:
                flag = True
                self.adj[node][char] = self.new_node()
            node = self.adj[node][char]
            if node in self.reverse_idx:
                return self.reverse_idx[node]
        self.reverse_idx[node] = word_idx

        # traverse
        if not flag:
            while not flag:
                flag = True
                for char, v in self.adj[node].items():
                    node = v
                    flag = False
                    break
            return self.reverse_idx[node]

        return -1

    def new_node(self) -> int:
        cur_cnt = len(self.adj)
        self.adj[cur_cnt] = {}
        return cur_cnt


class Mediator:
    def read_input(self) -> Mediator:
        global n, some_list
        readline = sys.stdin.readline

        n = int(readline().rstrip())
        some_list = list(readline().split())
        return self

    def solve(self) -> Tuple[int, int]:
        """
        main logic comes here
        """
        global n, some_list
        trie_tree = TrieTree()
        for i, word in enumerate(some_list):
            idx = trie_tree.add(word, i)
            if idx != -1:
                return (i, idx)

        return (-1, -1)


def main(test_case: bool = False):
    def main_part():
        output = Mediator().read_input().solve()
        print(output)

    if test_case:
        t = int(input())
        for _ in range(t):
            main_part()
    else:
        main_part()


if __name__ == "__main__":
    main(False)
